{
	"$schema": "https://json-schema.org/draft/2020-12/schema",
	"$id": "/schema/material",
	"title": "material",
	"description": "Describes a rendering pipeline",
	"type": "object",
	"properties": {
		"vertexShader": {
			"type": "string",
			"description": "ULID for the vertex shader to use.",
			"pattern": "[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}"
		},
		"fragmentShader": {
			"type": "string",
			"description": "ULID for the fragment shader to use.",
			"pattern": "[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}"
		},
		"input": {
			"type": "string",
			"enum": [
				"vertex2d",
				"vertex3d"
			],
			"description": "The type of vertex to use as input, if any. The default is none."
		},
		"primitiveType": {
			"type": "string",
			"enum": [
				"triangleList",
				"triangleStrip",
				"lineList",
				"lineStrip",
				"pointList"
			],
			"description": "The geometric primitive to use. Default is triangleList."
		},
		"sampleCount": {
			"enum": [
				1,
				2,
				4,
				8
			],
			"description": "The sample count to use. Default is 1.",
			"type": "integer"
		},
		"rasterizer": {
			"type": "object",
			"description": "Settings for the rasterization stage of the pipeline.",
			"properties": {
				"fillMode": {
					"type": "string",
					"enum": [
						"fill",
						"line"
					],
					"description": "How to fill the geometry. Default is fill."
				},
				"cullMode": {
					"type": "string",
					"enum": [
						"none",
						"back",
						"front"
					],
					"description": "Defines what triangles should be culled (back-facing or front√®facing), if any. Defaults to none."
				},
				"enableDepthBias": {
					"description": "Whether to apply bias to fragment depth values",
					"type": "boolean"
				},
				"enableDepthClip": {
					"description": "true to enable depth clip, false to enable depth clamp.",
					"type": "boolean"
				}
			},
			"if": {
				"properties": {
					"enableDepthBias": {
						"const": true
					}
				}
			},
			"then": {
				"properties": {
					"depthBiasClamp": {
						"description": "Maximum (or minimum) depth bias for a fragment.",
						"type": "number"
					},
					"depthBiasConstantFactor": {
						"description": "A scalar factor controlling the depth value added to each fragment.",
						"type": "number"
					},
					"depthBiasSlopeFactor": {
						"description": "A scalar factor applied to a fragment's slope in depth calculations.",
						"type": "number"
					}
				}
			}
		},
		"depthStencil": {
			"description": "Describes the depth/stencil state of the pipeline. Ignored if hasDepthStencilTarget is false",
			"properties": {
				"format": {
					"description": "The format for the depth/stencil target, if used.",
					"type": "string",
					"enum": [
						"d16unorm",
						"d24unorm",
						"d32float",
						"d24unorm_s8uint",
						"d32float_s8uint"
					]
				},
				"enableStencilTest": {
					"description": "Whether to use stencil testing. Defaults to false.",
					"type": "boolean"
				},
				"enableDepthTest": {
					"description": "Whether to use depth testing. Defaults to false.",
					"type": "boolean"
				},
				"enableDepthWrite": {
					"description": "Whether to enable writing to the depth target. Defaults to false.",
					"type": "boolean"
				},
				"compareOp": {
					"description": "The operation to use for depth testing.",
					"type": "string",
					"enum": [
						"always",
						"never",
						"equal",
						"notEqual",
						"less",
						"lessOrEqual",
						"greater",
						"greaterOrEqual"
					]
				}
			},
			"if": {
				"properties": {
					"enableStencilTest": {
						"const": true
					}
				}
			},
			"then": {
				"properties": {
					"frontStencil": {
						"description": "Describes the stencil operation to perform from front-facing triangles",
						"properties": {
							"passOp": {
								"description": "The operation to use when the stencil and depth tests both pass.",
								"type": "string",
								"enum": [
									"zero",
									"replace",
									"invert",
									"decrementAndWrap",
									"decrementAndClamp",
									"incrementAndWrap",
									"incrementAndClamp"
								]
							},
							"failOp": {
								"description": "The operation to use when the stencil test fails.",
								"type": "string",
								"enum": [
									"zero",
									"replace",
									"invert",
									"decrementAndWrap",
									"decrementAndClamp",
									"incrementAndWrap",
									"incrementAndClamp"
								]
							},
							"depthFailOp": {
								"description": "The operation to use when the stencil test passes but the depth test fails.",
								"type": "string",
								"enum": [
									"zero",
									"replace",
									"invert",
									"decrementAndWrap",
									"decrementAndClamp",
									"incrementAndWrap",
									"incrementAndClamp"
								]
							},
							"compareOp": {
								"description": "The comparison operation used in the stencil test",
								"type": "string",
								"enum": [
									"always",
									"never",
									"equal",
									"notEqual",
									"less",
									"lessOrEqual",
									"greater",
									"greaterOrEqual"
								]
							}
						}
					},
					"backStencil": {
						"description": "Describes the stencil operation to perform from back-facing triangles",
						"properties": {
							"passOp": {
								"description": "The operation to use when the stencil and depth tests both pass.",
								"type": "string",
								"enum": [
									"zero",
									"replace",
									"invert",
									"decrementAndWrap",
									"decrementAndClamp",
									"incrementAndWrap",
									"incrementAndClamp"
								]
							},
							"failOp": {
								"description": "The operation to use when the stencil test fails.",
								"type": "string",
								"enum": [
									"zero",
									"replace",
									"invert",
									"decrementAndWrap",
									"decrementAndClamp",
									"incrementAndWrap",
									"incrementAndClamp"
								]
							},
							"depthFailOp": {
								"description": "The operation to use when the stencil test passes but the depth test fails.",
								"type": "string",
								"enum": [
									"zero",
									"replace",
									"invert",
									"decrementAndWrap",
									"decrementAndClamp",
									"incrementAndWrap",
									"incrementAndClamp"
								]
							},
							"compareOp": {
								"description": "The comparison operation used in the stencil test",
								"type": "string",
								"enum": [
									"always",
									"never",
									"equal",
									"notEqual",
									"less",
									"lessOrEqual",
									"greater",
									"greaterOrEqual"
								]
							}
						}
					},
					"compareMask": {
						"description": "8-bit mask which controls which bits are used in the stencil test.",
						"value": "integer",
						"minimum": 0,
						"maximum": 255
					},
					"writeMask": {
						"description": "8-bit mask which controls which bits are updated by the stencil test.",
						"value": "integer",
						"minimum": 0,
						"maximum": 255
					}
				}
			},
			"required": [
				"format"
			]
		},
		"colorTargets": {
			"type": "array",
			"description": "Color target texture descriptions. Defaults to the swapchain texture.",
			"items": {
				"type": "object",
				"properties": {
					"format": {
						"type": "string",
						"enum": [
							"r8unorm",
							"rg8unorm",
							"rgba8unorm",
							"r16usorm",
							"rg16unorm",
							"rgba16unorm",
							"r8usorm",
							"rg8snorm",
							"rgba8unorm",
							"r16ssorm",
							"rg16snorm",
							"rgba16snorm",
							"r8int",
							"rg8int",
							"rgba8int",
							"r8uint",
							"rg8uint",
							"rgba8uint",
							"rgba8unorm_srgb",
							"bgra8unorm_srgb"
						]
					},
					"blending": {
						"type": "object",
						"description": "Describes the blending between the color output of the fragment shader and the color already present in the target.",
						"properties": {
							"colorWriteMask": {
								"description": "A bitmask controlling which channels of the target get updated. Defaults to all channels.",
								"type": "integer",
								"minimum": 0,
								"maximum": 15
							},
							"srcColorBlendFactor": {
								"type": "string",
								"enum": [
									"zero",
									"one",
									"srcColor",
									"srcAlpha",
									"dstColor",
									"dstAlpha",
									"oneMinusDstAlpha",
									"oneMinusSrcAlpha",
									"oneMinusSrcColor",
									"oneMinusDstColor",
									"constantColor",
									"oneMinusConstantColor",
									"srcAlphaSaturate"
								]
							},
							"dstColorBlendFactor": {
								"type": "string",
								"enum": [
									"zero",
									"one",
									"srcColor",
									"srcAlpha",
									"dstColor",
									"dstAlpha",
									"oneMinusDstAlpha",
									"oneMinusSrcAlpha",
									"oneMinusSrcColor",
									"oneMinusDstColor",
									"constantColor",
									"oneMinusConstantColor",
									"srcAlphaSaturate"
								]
							},
							"srcAlphaBlendFactor": {
								"type": "string",
								"enum": [
									"zero",
									"one",
									"srcColor",
									"srcAlpha",
									"dstColor",
									"dstAlpha",
									"oneMinusDstAlpha",
									"oneMinusSrcAlpha",
									"oneMinusSrcColor",
									"oneMinusDstColor",
									"constantColor",
									"oneMinusConstantColor",
									"srcAlphaSaturate"
								]
							},
							"dstAlphaBlendFactor": {
								"type": "string",
								"enum": [
									"zero",
									"one",
									"srcColor",
									"srcAlpha",
									"dstColor",
									"dstAlpha",
									"oneMinusDstAlpha",
									"oneMinusSrcAlpha",
									"oneMinusSrcColor",
									"oneMinusDstColor",
									"constantColor",
									"oneMinusConstantColor",
									"srcAlphaSaturate"
								]
							},
							"colorBlendOp": {
								"type": "string",
								"enum": [
									"add",
									"subtract",
									"reverseSubtract",
									"min",
									"max"
								]
							},
							"alphaBlendOp": {
								"type": "string",
								"enum": [
									"add",
									"subtract",
									"reverseSubtract",
									"min",
									"max"
								]
							}
						}
					}
				},
				"required": [
					"format"
				]
			}
		}
	},
	"required": [
		"vertexShader",
		"fragmentShader"
	]
}